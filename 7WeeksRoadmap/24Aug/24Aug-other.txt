Docker

docker is nothing but making sure application works same everywhere by combining , code ,dependencies,packages, etc into a single container

Imagine you have an app you built on your laptop.

- It works fine for you.
- But when you give it to a friend, they get errors:
    - “Python not installed”
    - “Library version mismatch”
    - “Database config missing”

**“It works on my machine” problem**.

Docker solves this by letting you package everything your app needs into a **container**.

A **container** is like a **sealed box** that has:

- Your code
- Runtime (Python, Node, Java, etc.)
- Dependencies (libraries, packages)
- Configurations (environment variables, files)

When you share the box, anyone can run your app exactly the same way—on Linux, Windows, Mac, or cloud servers.

## 5. How Developers Use Docker

- **Development:** Run apps with correct dependencies instantly.
- **Testing:** Test apps in clean, reproducible environments.
- **Deployment:** Ship the same container to production (no surprises).
- **Scaling:** Run multiple containers (with Kubernetes or Docker Swarm).

uses

1. **Consistency Across Machines**

- **Local dev issue:** Your app might run fine on your laptop, but fail on a teammate’s laptop or production server due to different OS, library versions, or configurations.
- **Docker benefit:** Everything (code + dependencies + configs) is inside the container. The app runs the **same everywhere** — Windows, Mac, Linux, cloud.

2. **Easy Setup**

- **Local dev issue:** New developers must install tools (Node, Python, databases, etc.), configure paths, fight with version conflicts.
- **Docker benefit:** One command `docker-compose up` can spin up your app + database + cache + APIs without manual setup.

3. **Reproducibility**

**Local dev issue:** Your local setup drifts over time (you update Node, OS packages, etc.), which breaks old projects.

**Docker benefit:** Containers freeze dependencies and environments, so you can rerun old projects exactly as before.

How to dockerize a full stack app

- **Frontend:** React app (runs on Node.js build server, serves static files)
- **Backend:** Express/Node.js API
- **Database:** MongoDB (or Postgres/MySQL)

my-app/
│
├── frontend/       # React app
│   └── Dockerfile
│
├── backend/        # Express API
│   └── Dockerfile
│
├── docker-compose.yml
└── [README.md](http://readme.md/)

BE docker file

```jsx
# Use Node.js base image
FROM node:18

# Set working directory
WORKDIR /app

# Copy package.json and install dependencies
COPY package*.json ./
RUN npm install

# Copy source code
COPY . .

# Expose API port
EXPOSE 5000

# Start the server
CMD ["npm", "start"]

```

FE 

```jsx
# Stage 1: Build React app
FROM node:18 AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Serve with Nginx
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

```

docker-compose

```jsx
version: "3.9"

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "5000:5000"
    environment:
      - MONGO_URI=mongodb://db:27017/mydb
    depends_on:
      - db

  db:
    image: mongo:6
    restart: always
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

volumes:
  mongo_data:

```

run the app

docker-compose up --build

- `frontend` → runs React on port **3000**
- `backend` → runs Express API on port **5000**
- `db` → MongoDB runs on port **27017**

with this one command whole app will run

to stop

docker-compose down
everything shuts down cleanly.