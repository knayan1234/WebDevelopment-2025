A **JSON Web Token** (JWT) is a standard used to securely transmit information between a client (like a frontend application) and a server (the backend). It is commonly used to verify users' identities, authenticate them, and ensure safe communication between the two.
It’s just a **string** (like `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) that carries **verified** info about the user.

how it works

1. **User Logs In**: The client (browser) sends login credentials to the [**server**](https://www.geeksforgeeks.org/computer-networks/what-is-server/). Eg:{ "username": "alice", "password": "12345" }
2. **Server Generates JWT**: If credentials are valid, the server creates a JWT containing user data and signs it with a secret key. Eg:send JWT back to user
3. **Token Sent to Client**: The JWT is sent back to the client and stored (usually in [**localStorage**](https://www.geeksforgeeks.org/javascript/javascript-localstorage/) or a cookie).
4. **Client Sends Token in Requests**: For protected routes, the client includes the JWT in the Authorization header (Bearer Token).Eg:Authorization: Bearer <your_JWT_here>
5. **Server Verifies and Responds**: The server verifies the token, extracts user info, and processes the request if valid.

Tokens are used to securely transmit sensitive information between the client and the server. Instead of sending plain data

A JWT consists of three parts, separated by dots (.)
`Header. Payload. Signature`

- **Header** → says what algorithm was used (e.g., HS256)
- **Payload** → the data (e.g., userId, role)
- **Signature** → proves it’s legit (created using a secret key only the server knows)

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0IiwibmFtZSI6IkFsaWNlIiwicm9sZSI6InVzZXIifQ.
TJVA95OrM7E2cBab30RMHrHDcEfxJoZz6apMZ

• **Stateless Authentication**: No need to store user sessions on the server; JWT contains all necessary data.

Without JWT:

- Every time you make an API call, you’d have to send username & password again → insecure & slow.

With JWT:

- You log in **once** → server gives you a JWT.
- You send that JWT on every request instead of username/password.
- Server **trusts** it because it’s signed.

 **In stateful authentication (old-school sessions)**

When you log in, the server **stores your session** in memory or in a database.

Your browser gets a **session ID** in a cookie.

On every request, the server looks up that session ID in its storage to find your user.

The server must keep **state** for every logged-in user.

If the server restarts, all sessions are gone unless stored in a DB.

**In stateless authentication (JWT)**

After you log in, the server gives you a JWT **that contains all the info needed** (like user ID, role, expiry).

The JWT is **signed** so the server can verify it hasn’t been changed.

The server **does NOT store anything** about you between requests — it just checks the JWT on each request.

No lookup table, no in-memory session. The “state” is entirely inside the token you carry.

**Scalability** → You can have multiple backend servers, and any one of them can verify a JWT without sharing session storage.

**OAuth delegated login**

its happening in daily life scenarios . when we try to open a new site there will be option to create an act or login with google , github etc 

whats happen when we click login with … is instead of taking username na dpasssword into that particular site they redirect to google . we login google using our cred . google redirect us back to same website

but during this redirection google send a token to website . wbsite uses this token for future authentications

delegated means instead of taking the security and responsibilty of credentials just redirecting to trusted sites and using the token providing by them

How can we securely manage auth tokens in web

Keep them secret, prevent XSS/CSRF attacks, and avoid accidental exposure in logs or URLs.

1.Always use **HTTPS** so tokens aren’t sent in plain text over the network.

2.

- Don’t log tokens to the console (especially in production).
- Don’t include tokens in query params or error messages.

3.

If using cookies for tokens:

Add `SameSite=Strict` or `SameSite=Lax` to prevent cross-site requests.

Or use **double-submit CSRF tokens** — send an extra anti-CSRF token in headers that the server validates.

1.  **Make Tokens Short-Lived**

Access tokens should expire quickly (e.g., **5–15 minutes**).

Use a **refresh token** (stored securely, usually in an HTTP-only cookie) to get a new access token.

1. **HTTP-only Secure Cookies**
    - Set by your backend with `HttpOnly` and `Secure` flags.
    - JavaScript **cannot** read them (prevents XSS token theft).
    - Sent automatically with each request to your domain (but this also means you need to guard against CSRF).
- **In-memory storage** (for short-lived sessions)
    - Store in a variable in JS runtime.
    - Token disappears when page reloads, so works best for single-page apps where you refresh tokens silently.

❌ **Do NOT** store tokens in:

- **LocalStorage** – Easy target for XSS attacks (JavaScript can read it if malicious script runs).
- **SessionStorage** – Same XSS problem as localStorage.
- **URL parameters** – Tokens end up in browser history, server logs, and analytics.